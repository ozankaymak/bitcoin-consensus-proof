use anyhow::{anyhow, Context, Result};
use bitcoin::{hashes::Hash, BlockHash}; // For BlockHash::all_zeros() and type consistency
use borsh::{BorshDeserialize, BorshSerialize}; // For JmtKeyValueChanges
use dotenv::dotenv;
use hex::FromHex;
use jsonrpsee::http_client::{HttpClient, HttpClientBuilder};
use risc0_zkvm::{
    serde::from_slice as risc0_from_slice, // Using risc0's from_slice if needed for specific receipt parts
    sha::Digest,                           // For IMAGE_ID
    Receipt,                               // For Receipt deserialization and verification
};
use serde::{Deserialize as SerdeDeserialize, Serialize as SerdeSerialize};
use std::{
    env,
    time::{Duration, Instant},
};
use tracing::{debug, error, info, warn, Level};
use tracing_subscriber::EnvFilter;

// Assuming these types are available from your project structure
// (e.g., from a shared crate like `bitcoin_consensus_core`)
// For this example, they are redefined here or assumed to be in scope.
// If they are in `bitcoin_consensus_core`, you'd use `bitcoin_consensus_core::utxo_set::{KeyOutPoint, UTXO};`
// For now, let's assume they are brought into scope correctly from the same crate or a dependency.
// If they are in the same crate (host), you might use `crate::utxo_set::{KeyOutPoint, UTXO}` if `utxo_set.rs` is part of `host` lib.
// For a binary, it often depends on the library part of its own package or external crates.
// Assuming they are available via `bitcoin_consensus_core` for this example.
use bitcoin_consensus_core::utxo_set::{KeyOutPoint, UTXO};

// --- RPC Data Structures (must match server's definitions) ---
mod rpc_helpers {
    use serde::{de::Error, Deserializer, Serializer};
    pub mod hex_array_32 {
        use serde::Deserialize;

        use super::*;
        // Using external `hex` crate as per the fixed server.rs
        // Ensure `hex` is a dependency for the client.
        pub fn serialize<S>(array: &[u8; 32], serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            serializer.serialize_str(&hex::encode(array))
        }
        pub fn deserialize<'de, D>(deserializer: D) -> std::result::Result<[u8; 32], D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            hex::decode(s)
                .map_err(Error::custom)?
                .try_into()
                .map_err(|_| {
                    Error::custom(format!(
                        "Invalid hex length for [u8; 32], expected 32 bytes"
                    ))
                })
        }
    }

    pub mod base64_vec_u8 {
        use super::*;
        use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
        use serde::Deserialize;
        pub fn serialize<S>(bytes: &Vec<u8>, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            serializer.serialize_str(&BASE64_STANDARD.encode(bytes))
        }
        pub fn deserialize<'de, D>(deserializer: D) -> std::result::Result<Vec<u8>, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            BASE64_STANDARD.decode(s.as_bytes()).map_err(Error::custom)
        }
    }
}

#[derive(SerdeSerialize, SerdeDeserialize, Clone, Debug)]
pub struct RpcProofEntry {
    pub block_height: u32,
    #[serde(with = "rpc_helpers::hex_array_32")]
    pub block_hash: [u8; 32],
    #[serde(with = "rpc_helpers::hex_array_32")]
    pub prev_hash: [u8; 32],
    pub method_id: [u32; 8], // As per server's AppState.bitcoin_guest_id conversion
    #[serde(with = "rpc_helpers::base64_vec_u8")]
    pub receipt: Vec<u8>,
    pub last_version: u64,
}

#[derive(SerdeSerialize, SerdeDeserialize, Clone, Debug)]
pub struct RpcProofChainElement {
    pub proof_entry: RpcProofEntry,
    #[serde(with = "rpc_helpers::base64_vec_u8")]
    pub jmt_operations_bytes: Vec<u8>,
}

#[derive(Debug, SerdeDeserialize, SerdeSerialize)]
pub struct GetProofChainParams {
    #[serde(with = "rpc_helpers::hex_array_32")]
    pub client_block_hash: [u8; 32],
}

// This trait is generated by `#[rpc(server, client)]` on the server side.
// The client uses it to make type-safe calls.
#[jsonrpsee::proc_macros::rpc(client)]
pub trait BitcoinConsensusRpcClient {
    #[method(name = "getProofChain")]
    async fn get_proof_chain(
        &self,
        params: GetProofChainParams,
    ) -> jsonrpsee::core::RpcResult<Vec<RpcProofChainElement>>;
}
// --- End RPC Data Structures ---

/// JMT Key-Value changes received from the server.
/// This definition must match the one used by the server when serializing this data.
#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, SerdeSerialize)] // Added SerdeSerialize for easier debug printing
pub struct JmtKeyValueChanges {
    pub creations: Vec<(KeyOutPoint, UTXO)>,
    pub deletions: Vec<KeyOutPoint>,
}

#[derive(Debug)]
struct ClientConfig {
    server_url: String,
    guest_image_id: Digest,
    sync_interval_secs: u64,
}

impl ClientConfig {
    fn load() -> Result<Self> {
        dotenv().ok();
        let guest_image_id_hex = env::var("CLIENT_GUEST_IMAGE_ID_HEX")
            .context("CLIENT_GUEST_IMAGE_ID_HEX must be set in .env for client mode")?;
        if guest_image_id_hex.is_empty() {
            return Err(anyhow!("CLIENT_GUEST_IMAGE_ID_HEX cannot be empty."));
        }
        let guest_image_id = Digest::from_hex(&guest_image_id_hex).map_err(|e| {
            anyhow!(
                "Invalid CLIENT_GUEST_IMAGE_ID_HEX '{}': {}",
                guest_image_id_hex,
                e
            )
        })?;

        Ok(ClientConfig {
            server_url: env::var("CLIENT_SERVER_URL")
                .unwrap_or_else(|_| "http://127.0.0.1:9944".to_string()),
            guest_image_id,
            sync_interval_secs: env::var("CLIENT_SYNC_INTERVAL_SECS")
                .unwrap_or_else(|_| "30".to_string())
                .parse()?,
        })
    }
}

async fn run_client_sync_loop(config: ClientConfig) -> Result<()> {
    info!("RPC Client: Connecting to server at {}", config.server_url);
    let client = HttpClientBuilder::default()
        .build(&config.server_url)
        .with_context(|| format!("Failed to connect to RPC server at {}", config.server_url))?;

    let mut current_client_block_hash_bytes = BlockHash::all_zeros().to_byte_array();

    loop {
        let current_block_hash_for_request = BlockHash::from_slice(&current_client_block_hash_bytes)
             .unwrap_or_else(|e| {
                error!("Client state error: invalid current_client_block_hash_bytes. Resetting to genesis. Error: {}", e);
                BlockHash::all_zeros()
            });

        info!(
            "RPC Client: Requesting proof chain from hash: {}",
            hex::encode(current_client_block_hash_bytes)
        );

        let params = GetProofChainParams {
            client_block_hash: current_client_block_hash_bytes,
        };

        let request_start_time = Instant::now();
        match client.get_proof_chain(params).await {
            Ok(proof_chain) => {
                let request_duration = request_start_time.elapsed();
                if proof_chain.is_empty() {
                    if current_client_block_hash_bytes == BlockHash::all_zeros().to_byte_array() {
                        info!("RPC Client: Received empty proof chain for genesis request. Server might be starting or has no proofs. Retrying in {}s.", config.sync_interval_secs);
                    } else {
                        info!("RPC Client: Received empty proof chain. Assuming up-to-date with hash {}. Retrying in {}s.", current_block_hash_for_request, config.sync_interval_secs);
                    }
                } else {
                    info!(
                        "RPC Client: Received {} proof elements in {:.2?}. Processing...",
                        proof_chain.len(),
                        request_duration
                    );
                    let mut new_tip_hash_bytes = current_client_block_hash_bytes;

                    for (idx, element) in proof_chain.iter().enumerate() {
                        info!(
                            "RPC Client: Processing element {}/{} for block height {} (hash: {})",
                            idx + 1,
                            proof_chain.len(),
                            element.proof_entry.block_height,
                            hex::encode(element.proof_entry.block_hash)
                        );

                        // 1. Verify RISC Zero Receipt
                        let receipt_bytes = &element.proof_entry.receipt;
                        // Server stores receipt via borsh::to_vec(&receipt), so client uses borsh::from_slice
                        let receipt: Receipt = borsh::from_slice(receipt_bytes)
                            .map_err(|e| anyhow!("Failed to borsh deserialize receipt: {}", e))?;

                        receipt.verify(config.guest_image_id.clone()) // Use the Digest directly
                            .map_err(|e| anyhow!("Receipt verification failed for block height {}: {} (Image ID: {})", 
                                element.proof_entry.block_height, e, config.guest_image_id))?;
                        info!(
                            "RPC Client:   Receipt for block height {} verified successfully.",
                            element.proof_entry.block_height
                        );

                        // 2. Deserialize JMT K-V changes
                        let jmt_kv_changes =
                            JmtKeyValueChanges::try_from_slice(&element.jmt_operations_bytes)
                                .map_err(|e| {
                                    anyhow!(
                                        "Failed to deserialize JmtKeyValueChanges for block {}: {}",
                                        element.proof_entry.block_height,
                                        e
                                    )
                                })?;

                        debug!(
                            "RPC Client:     Creations: {}",
                            jmt_kv_changes.creations.len()
                        );
                        for (k, v) in jmt_kv_changes.creations.iter().take(2) {
                            debug!(
                                "      + TxID: ...{}, vout: {} -> Value ({} sats), Height: {}",
                                hex::encode(&k.txid[28..]),
                                k.vout,
                                v.value,
                                v.block_height
                            );
                        }
                        debug!(
                            "RPC Client:     Deletions: {}",
                            jmt_kv_changes.deletions.len()
                        );
                        for k in jmt_kv_changes.deletions.iter().take(2) {
                            debug!(
                                "      - TxID: ...{}, vout: {}",
                                hex::encode(&k.txid[28..]),
                                k.vout
                            );
                        }

                        // 3. Apply Delta to client JMT (unimplemented)
                        info!("RPC Client:   Applying JMT K-V changes to local JMT... (unimplemented for block height {})", element.proof_entry.block_height);
                        // Placeholder: apply_delta_to_client_jmt(&mut client_jmt_state, jmt_kv_changes);

                        // 4. Verify client JMT root matches receipt output (unimplemented)
                        // let output = BitcoinConsensusCircuitOutput::try_from_slice(&receipt.journal.bytes)
                        //    .map_err(|e| anyhow!("Failed to deserialize circuit output: {:?}", e))?;
                        // let expected_jmt_root = output.bitcoin_state.utxo_set_commitment.jmt_root;
                        // let client_current_jmt_root = client_jmt_state.root_hash()?; // Example
                        // if client_current_jmt_root != expected_jmt_root {
                        //     error!("JMT root hash Mismatch after applying delta for block {}!", element.proof_entry.block_height);
                        //     return Err(anyhow!("JMT root hash mismatch after applying delta for block {}!", element.proof_entry.block_height));
                        // }
                        // info!("RPC Client:   JMT root hash matches for block {}.", element.proof_entry.block_height);
                        if idx == proof_chain.len() - 1 {
                            // Only if this is the last element processed in the chain
                            new_tip_hash_bytes = element.proof_entry.block_hash;
                        }
                    }
                    if !proof_chain.is_empty() {
                        current_client_block_hash_bytes = new_tip_hash_bytes;
                        info!(
                            "RPC Client: Finished processing proof chain. Client tip now at: {}",
                            hex::encode(current_client_block_hash_bytes)
                        );
                    }
                }
            }
            Err(e) => match e {
                jsonrpsee::core::ClientError::Call(call_error) => {
                    error!(
                        "RPC Client: getProofChain Call Error: {:?}. Retrying in {}s.",
                        call_error.message(),
                        config.sync_interval_secs
                    );
                }
                _ => {
                    error!(
                        "RPC Client: getProofChain RPC call failed: {}. Retrying in {}s.",
                        e, config.sync_interval_secs
                    );
                }
            },
        }
        tokio::time::sleep(Duration::from_secs(config.sync_interval_secs)).await;
    }
    // Ok(()) // This loop is infinite, so Ok(()) is not reachable here.
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new(Level::DEBUG.to_string())),
        )
        .init();

    info!("Bitcoin Consensus Client starting...");
    let config = ClientConfig::load().context("Failed to load client configuration")?;

    // Initialize client's JMT and other state here if needed
    // let mut client_jmt_state = initialize_client_jmt_somehow();

    if let Err(e) = run_client_sync_loop(config /*, &mut client_jmt_state */).await {
        error!("Client encountered an error: {}", e);
        return Err(e);
    }
    Ok(())
}
