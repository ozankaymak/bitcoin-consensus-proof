use anyhow::{anyhow, Context, Result};
use bitcoin::{hashes::Hash, BlockHash}; // For BlockHash::all_zeros() and type consistency
use borsh::{BorshDeserialize, BorshSerialize}; // For JmtKeyValueChanges
use dotenv::dotenv;
use hex::FromHex;
use jsonrpsee::http_client::{HttpClient, HttpClientBuilder};
use risc0_zkvm::{
    serde::from_slice as risc0_from_slice, // Using risc0's from_slice if needed for specific receipt parts
    sha::Digest,                           // For IMAGE_ID
    Receipt,                               // For Receipt deserialization and verification
};
use serde::{Deserialize as SerdeDeserialize, Serialize as SerdeSerialize};
use std::{
    env,
    path::PathBuf, // Added for PathBuf
    time::{Duration, Instant},
};
use tracing::{debug, error, info, warn, Level};
use tracing_subscriber::EnvFilter;

// Assuming these types are available from your project structure
use bitcoin_consensus_core::{
    utxo_set::{KeyOutPoint, OutPointBytes, UTXOBytes, UTXO}, // Added OutPointBytes, UTXOBytes
    BitcoinConsensusCircuitOutput,                           // Added
};

// JMT and RocksDB imports
use host::rocks_db::RocksDbStorage; // This line assumes `host::rocks_db` is accessible.
                                    // If client.rs is in a separate crate, ensure the `host` crate (or the relevant module)
                                    // is a dependency and `RocksDbStorage` is public.
use jmt::{KeyHash, OwnedValue, RootHash, Sha256Jmt}; // Added JMT types

// --- RPC Data Structures (must match server's definitions) ---
mod rpc_helpers {
    use serde::{de::Error, Deserializer, Serializer};
    pub mod hex_array_32 {
        use serde::Deserialize;

        use super::*;
        // Using external `hex` crate as per the fixed server.rs
        // Ensure `hex` is a dependency for the client.
        pub fn serialize<S>(array: &[u8; 32], serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            serializer.serialize_str(&hex::encode(array))
        }
        pub fn deserialize<'de, D>(deserializer: D) -> std::result::Result<[u8; 32], D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            hex::decode(s)
                .map_err(Error::custom)?
                .try_into()
                .map_err(|_| {
                    Error::custom(format!(
                        "Invalid hex length for [u8; 32], expected 32 bytes"
                    ))
                })
        }
    }

    pub mod base64_vec_u8 {
        use super::*;
        use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
        use serde::Deserialize;
        pub fn serialize<S>(bytes: &Vec<u8>, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            serializer.serialize_str(&BASE64_STANDARD.encode(bytes))
        }
        pub fn deserialize<'de, D>(deserializer: D) -> std::result::Result<Vec<u8>, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            BASE64_STANDARD.decode(s.as_bytes()).map_err(Error::custom)
        }
    }
}

#[derive(SerdeSerialize, SerdeDeserialize, Clone, Debug)]
pub struct RpcProofEntry {
    pub block_height: u32,
    #[serde(with = "rpc_helpers::hex_array_32")]
    pub block_hash: [u8; 32],
    #[serde(with = "rpc_helpers::hex_array_32")]
    pub prev_hash: [u8; 32],
    pub method_id: [u32; 8], // As per server's AppState.bitcoin_guest_id conversion
    #[serde(with = "rpc_helpers::base64_vec_u8")]
    pub receipt: Vec<u8>,
    pub last_version: u64,
}

#[derive(SerdeSerialize, SerdeDeserialize, Clone, Debug)]
pub struct RpcProofChainElement {
    pub proof_entry: RpcProofEntry,
    #[serde(with = "rpc_helpers::base64_vec_u8")]
    pub jmt_operations_bytes: Vec<u8>,
}

#[derive(Debug, SerdeDeserialize, SerdeSerialize)]
pub struct GetProofChainParams {
    #[serde(with = "rpc_helpers::hex_array_32")]
    pub client_block_hash: [u8; 32],
}

// This trait is generated by `#[rpc(server, client)]` on the server side.
// The client uses it to make type-safe calls.
#[jsonrpsee::proc_macros::rpc(client)]
pub trait BitcoinConsensusRpcClient {
    #[method(name = "getProofChain")]
    async fn get_proof_chain(
        &self,
        params: GetProofChainParams,
    ) -> jsonrpsee::core::RpcResult<Vec<RpcProofChainElement>>;
}
// --- End RPC Data Structures ---

/// JMT Key-Value changes received from the server.
/// This definition must match the one used by the server when serializing this data.
#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, SerdeSerialize)] // Added SerdeSerialize for easier debug printing
pub struct JmtKeyValueChanges {
    pub creations: Vec<(KeyOutPoint, UTXO)>,
    pub deletions: Vec<KeyOutPoint>,
}

#[derive(Debug)]
struct ClientConfig {
    server_url: String,
    guest_image_id: Digest,
    sync_interval_secs: u64,
    rocks_db_path_client: PathBuf, // Added for client's RocksDB
}

impl ClientConfig {
    fn load() -> Result<Self> {
        dotenv().ok();
        let guest_image_id_hex = env::var("CLIENT_GUEST_IMAGE_ID_HEX")
            .context("CLIENT_GUEST_IMAGE_ID_HEX must be set in .env for client mode")?;
        if guest_image_id_hex.is_empty() {
            return Err(anyhow!("CLIENT_GUEST_IMAGE_ID_HEX cannot be empty."));
        }
        let guest_image_id = Digest::from_hex(&guest_image_id_hex).map_err(|e| {
            anyhow!(
                "Invalid CLIENT_GUEST_IMAGE_ID_HEX '{}': {}",
                guest_image_id_hex,
                e
            )
        })?;

        Ok(ClientConfig {
            server_url: env::var("CLIENT_SERVER_URL")
                .unwrap_or_else(|_| "http://127.0.0.1:9944".to_string()),
            guest_image_id,
            sync_interval_secs: env::var("CLIENT_SYNC_INTERVAL_SECS")
                .unwrap_or_else(|_| "30".to_string())
                .parse()?,
            rocks_db_path_client: PathBuf::from(
                env::var("CLIENT_ROCKS_DB_PATH")
                    .unwrap_or_else(|_| "data/utxo_db_client".to_string()),
            ),
        })
    }
}

async fn run_client_sync_loop(
    config: ClientConfig,
    client_jmt_storage: RocksDbStorage, // Pass RocksDbStorage instance
) -> Result<()> {
    info!("RPC Client: Connecting to server at {}", config.server_url);
    let client = HttpClientBuilder::default()
        .build(&config.server_url)
        .with_context(|| format!("Failed to connect to RPC server at {}", config.server_url))?;

    let mut current_client_block_hash_bytes = BlockHash::all_zeros().to_byte_array();

    loop {
        let current_block_hash_for_request = BlockHash::from_slice(&current_client_block_hash_bytes)
             .unwrap_or_else(|e| {
                error!("Client state error: invalid current_client_block_hash_bytes. Resetting to genesis. Error: {}", e);
                BlockHash::all_zeros()
            });

        info!(
            "RPC Client: Requesting proof chain from hash: {}",
            hex::encode(current_client_block_hash_bytes)
        );

        let params = GetProofChainParams {
            client_block_hash: current_client_block_hash_bytes,
        };

        let request_start_time = Instant::now();
        match client.get_proof_chain(params).await {
            Ok(proof_chain) => {
                let request_duration = request_start_time.elapsed();
                if proof_chain.is_empty() {
                    if current_client_block_hash_bytes == BlockHash::all_zeros().to_byte_array() {
                        info!("RPC Client: Received empty proof chain for genesis request. Server might be starting or has no proofs. Retrying in {}s.", config.sync_interval_secs);
                    } else {
                        info!("RPC Client: Received empty proof chain. Assuming up-to-date with hash {}. Retrying in {}s.", current_block_hash_for_request, config.sync_interval_secs);
                    }
                } else {
                    info!(
                        "RPC Client: Received {} proof elements in {:.2?}. Processing...",
                        proof_chain.len(),
                        request_duration
                    );
                    let mut new_tip_hash_bytes = current_client_block_hash_bytes;

                    for (idx, element) in proof_chain.iter().enumerate() {
                        info!(
                            "RPC Client: Processing element {}/{} for block height {} (hash: {}) target JMT version: {}",
                            idx + 1,
                            proof_chain.len(),
                            element.proof_entry.block_height,
                            hex::encode(element.proof_entry.block_hash),
                            element.proof_entry.last_version
                        );

                        // 1. Verify RISC Zero Receipt
                        let receipt_bytes = &element.proof_entry.receipt;
                        // Server stores receipt via borsh::to_vec(&receipt), so client uses borsh::from_slice
                        let receipt: Receipt = borsh::from_slice(receipt_bytes)
                            .map_err(|e| anyhow!("Failed to borsh deserialize receipt: {}", e))?;

                        receipt.verify(config.guest_image_id.clone()) // Use the Digest directly
                            .map_err(|e| anyhow!("Receipt verification failed for block height {}: {} (Image ID: {})",
                                element.proof_entry.block_height, e, config.guest_image_id))?;
                        info!(
                            "RPC Client:   Receipt for block height {} verified successfully.",
                            element.proof_entry.block_height
                        );

                        // 2. Deserialize JMT K-V changes
                        let jmt_kv_changes =
                            JmtKeyValueChanges::try_from_slice(&element.jmt_operations_bytes)
                                .map_err(|e| {
                                    anyhow!(
                                        "Failed to deserialize JmtKeyValueChanges for block {}: {}",
                                        element.proof_entry.block_height,
                                        e
                                    )
                                })?;

                        debug!(
                            "RPC Client:     JMT Creations: {}",
                            jmt_kv_changes.creations.len()
                        );
                        for (k, v) in jmt_kv_changes.creations.iter().take(2) {
                            debug!(
                                "      + TxID: ...{}, vout: {} -> Value ({} sats), Height: {}",
                                hex::encode(&k.txid[28..]),
                                k.vout,
                                v.value,
                                v.block_height
                            );
                        }
                        debug!(
                            "RPC Client:     JMT Deletions: {}",
                            jmt_kv_changes.deletions.len()
                        );
                        for k in jmt_kv_changes.deletions.iter().take(2) {
                            debug!(
                                "      - TxID: ...{}, vout: {}",
                                hex::encode(&k.txid[28..]),
                                k.vout
                            );
                        }

                        // 3. Apply Delta to client JMT
                        info!(
                            "RPC Client:   Applying JMT K-V changes to local JMT for version {}...",
                            element.proof_entry.last_version
                        );
                        let version_for_this_delta = element.proof_entry.last_version;
                        let mut updates_for_jmt: Vec<(KeyHash, Option<OwnedValue>)> = Vec::new();

                        for key_out_point in &jmt_kv_changes.deletions {
                            let key_bytes = OutPointBytes::from(*key_out_point);
                            let key_hash = KeyHash::with::<sha2::Sha256>(key_bytes.as_ref());
                            updates_for_jmt.push((key_hash, None));
                        }

                        for (key_out_point, utxo) in &jmt_kv_changes.creations {
                            let key_bytes = OutPointBytes::from(*key_out_point);
                            let key_hash = KeyHash::with::<sha2::Sha256>(key_bytes.as_ref());
                            let utxo_bytes_struct = UTXOBytes::from(utxo.clone());
                            let owned_value: OwnedValue = utxo_bytes_struct.0;
                            updates_for_jmt.push((key_hash, Some(owned_value)));
                        }

                        let client_tree = client_jmt_storage.get_jmt();
                        let (calculated_new_root, node_batch) = client_tree
                            .put_value_set(updates_for_jmt, version_for_this_delta)
                            .with_context(|| {
                                format!(
                                    "Failed to apply JMT updates for version {}",
                                    version_for_this_delta
                                )
                            })?;

                        client_jmt_storage
                            .update_with_batch(
                                calculated_new_root,
                                node_batch,
                                version_for_this_delta,
                            )
                            .with_context(|| {
                                format!(
                                    "Failed to write JMT batch to RocksDB for version {}",
                                    version_for_this_delta
                                )
                            })?;
                        info!(
                            "RPC Client:   Delta applied. Client JMT root for version {}: {:?}",
                            version_for_this_delta, calculated_new_root
                        );

                        // 4. Verify client JMT root matches receipt output
                        let output_from_receipt = BitcoinConsensusCircuitOutput::try_from_slice(&receipt.journal.bytes)
                           .map_err(|e| anyhow!("Failed to deserialize circuit output from receipt journal for block {}: {:?}", element.proof_entry.block_height, e))?;

                        let expected_jmt_root_from_receipt = output_from_receipt
                            .bitcoin_state
                            .utxo_set_commitment
                            .jmt_root;

                        if calculated_new_root != expected_jmt_root_from_receipt {
                            error!(
                                "CRITICAL: JMT root hash Mismatch after applying delta for block height {} (JMT version {})!",
                                element.proof_entry.block_height, version_for_this_delta
                            );
                            error!("  Client calculated JMT root: {:?}", calculated_new_root);
                            error!(
                                "  Receipt expected JMT root:  {:?}",
                                expected_jmt_root_from_receipt
                            );
                            return Err(anyhow!(
                                "JMT root hash mismatch for block height {} (JMT version {})!",
                                element.proof_entry.block_height,
                                version_for_this_delta
                            ));
                        }
                        info!("RPC Client:   JMT root hash matches receipt for block height {} (JMT version {}).", element.proof_entry.block_height, version_for_this_delta);

                        if idx == proof_chain.len() - 1 {
                            // Only if this is the last element processed in the chain
                            new_tip_hash_bytes = element.proof_entry.block_hash;
                        }
                    }
                    if !proof_chain.is_empty() {
                        current_client_block_hash_bytes = new_tip_hash_bytes;
                        info!(
                            "RPC Client: Finished processing proof chain. Client tip now at: {}",
                            hex::encode(current_client_block_hash_bytes)
                        );
                    }
                }
            }
            Err(e) => match e {
                jsonrpsee::core::ClientError::Call(call_error) => {
                    error!(
                        "RPC Client: getProofChain Call Error: {:?}. Retrying in {}s.",
                        call_error.message(),
                        config.sync_interval_secs
                    );
                }
                _ => {
                    error!(
                        "RPC Client: getProofChain RPC call failed: {}. Retrying in {}s.",
                        e, config.sync_interval_secs
                    );
                }
            },
        }
        tokio::time::sleep(Duration::from_secs(config.sync_interval_secs)).await;
    }
    // Ok(()) // This loop is infinite, so Ok(()) is not reachable here.
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new(Level::DEBUG.to_string())),
        )
        .init();

    info!("Bitcoin Consensus Client starting...");
    let config = ClientConfig::load().context("Failed to load client configuration")?;

    // Ensure client's RocksDB directory exists
    if let Some(parent_dir) = config.rocks_db_path_client.parent() {
        if !parent_dir.exists() {
            std::fs::create_dir_all(parent_dir).with_context(|| {
                format!(
                    "Failed to create directory for client RocksDB: {:?}",
                    parent_dir
                )
            })?;
        }
    } else if !config.rocks_db_path_client.exists()
        && config.rocks_db_path_client.file_name().is_some()
    {
        // Handle cases where the path is like "utxo_db_client" directly in current dir
        std::fs::create_dir_all(&config.rocks_db_path_client).with_context(|| {
            format!(
                "Failed to create client RocksDB directory: {:?}",
                config.rocks_db_path_client
            )
        })?;
    }

    // Initialize client's JMT storage
    let client_jmt_storage =
        RocksDbStorage::new(&config.rocks_db_path_client).with_context(|| {
            format!(
                "Failed to initialize client UTXO DB at {:?}",
                config.rocks_db_path_client
            )
        })?;
    info!(
        "Client JMT RocksDB initialized at: {:?}",
        config.rocks_db_path_client
    );

    if let Err(e) = run_client_sync_loop(config, client_jmt_storage).await {
        error!("Client encountered an error: {}", e);
        return Err(e);
    }
    Ok(())
}
